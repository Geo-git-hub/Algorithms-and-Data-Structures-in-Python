"""

Написать два алгоритма нахождения i-го по счёту простого числа.
"""
# Без использования «Решета Эратосфена»
# Представленный способ намного лучше алгоритма из файла task_2_1 по количеству затрачиваемого времени
# и по количеству итераций, но уступает алгоритму «Решето Эратосфена»

# в ходе замеров видно, что при поиске до 10 000 цифр идёт линейная зависимость по времени, затем логарифмическая
# могу ошибаться, но либо O(n), либо O(n log n)

# что касается оценки зависимости от количества итерации, то при 10-ом увеличении искомого списка цифр, коэффициент
# отношения изменения количества операции замерами начинает снижаться. При графическом представлении
# при малых n кривая была была бы похожа на линейную функцию, но при увеличении n приобритала характер логарифмической

import time
import timeit

result = []
user_input = int(input(f'Введите икомое количество простых чисел: '))

time_start = time.time()

i = 3
result.append(2)

while len(result) < user_input:
    for j in result:
        if (j * 2) > i:
            result.append(i)
            break
        if not i % j:
            break
    else:
        result.append(i)
    i += 2
time_fin = time.time()

print(result)
print(time_fin - time_start, 'c')

print(len(result))

# ----------спосбо 2 с Использованием алгоритма  "решето Эратосфена"
# Для приведённого ниже примера, из методички, расчёта списка простых чисел с использованием алгоритма  Эратосфена,
# видно, что увеличение n - искомое количество элементов списка простых чисел, не имеет линейную зависимость,
# а напоминает скорее логарифмическую

print('=' * 100)
n = i  # передаю значение из алгоритма выше - предел рассматриваемого интервала для определения i-го элемента

time_start = time.time()

a = [0] * n  # создание массива с n количеством элементов
for i in range(n):  # заполнение массива ...
    a[i] = i  # значениями от 0 до n-1

a[1] = 0
m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
while m < n:  # перебор всех элементов до заданного числа
    if a[m] != 0:  # если он не равен нулю, то
        j = m * 2  # увеличить в два раза (текущий элемент - простое число)
        while j < n:
            a[j] = 0  # заменить на 0
            j = j + m  # перейти в позицию на m больше
    m += 1
# вывод простых чисел на экран (может быть реализован как угодно)
b = []
for i in a:
    if a[i] != 0:
        b.append(a[i])
time_fin = time.time()

del a
print(b)
print(time_fin - time_start, 'c')
print(len(b))
